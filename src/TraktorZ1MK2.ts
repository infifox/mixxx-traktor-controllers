/** The maximum value for a slider or knob. */
const INPUT_NUMBER_MAX = 0x0fff;

/** Empty input value, used before any input has been received. */
const NULL_INPUT = new Uint8Array([
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
]);

/**
 * Graphical font data generated by the convert-font script, for drawing
 * onto the screens.
 */
const FONT_CHAR_WIDTH = 10;
const FONT_CHAR_HEIGHT = 16;
const FONT_DATA: Record<string, [Uint8Array, Uint8Array]> = {
  " ": [
    new Uint8Array([
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    ]),
    new Uint8Array([
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    ]),
  ],
  "!": [
    new Uint8Array([0xff, 0xff, 0xff, 0x87, 0x3, 0x3, 0x87, 0xff, 0xff, 0xff]),
    new Uint8Array([
      0xff, 0xff, 0xff, 0xff, 0xe4, 0xe4, 0xff, 0xff, 0xff, 0xff,
    ]),
  ],
  '"': [
    new Uint8Array([
      0xff, 0xff, 0xdf, 0xc3, 0xe3, 0xdf, 0xc3, 0xe3, 0xff, 0xff,
    ]),
    new Uint8Array([
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    ]),
  ],
  "#": [
    new Uint8Array([0xff, 0xdf, 0x7, 0x3, 0xdf, 0xdf, 0x7, 0x3, 0xdf, 0xff]),
    new Uint8Array([
      0xff, 0xfd, 0xe0, 0xf0, 0xfd, 0xfd, 0xe0, 0xf0, 0xfd, 0xff,
    ]),
  ],
  $: [
    new Uint8Array([0xff, 0x9f, 0xf, 0x6f, 0x2f, 0x7, 0x43, 0x6f, 0xdf, 0xff]),
    new Uint8Array([
      0xff, 0xfd, 0xfb, 0xe1, 0xf0, 0xfa, 0xfb, 0xf8, 0xfc, 0xff,
    ]),
  ],
  "%": [
    new Uint8Array([
      0xff, 0xc7, 0x9b, 0xb3, 0x47, 0x3f, 0x9f, 0xdf, 0xff, 0xff,
    ]),
    new Uint8Array([
      0xff, 0xff, 0xfd, 0xfc, 0xfe, 0xf1, 0xe6, 0xec, 0xf1, 0xff,
    ]),
  ],
  "&": [
    new Uint8Array([0xff, 0x47, 0x3, 0x3b, 0x7b, 0x83, 0xc7, 0x7f, 0x7f, 0xff]),
    new Uint8Array([
      0xff, 0xf0, 0xe0, 0xef, 0xee, 0xe4, 0xf0, 0xe6, 0xef, 0xf7,
    ]),
  ],
  "'": [
    new Uint8Array([
      0xff, 0xff, 0xff, 0xdf, 0xc3, 0xe3, 0xff, 0xff, 0xff, 0xff,
    ]),
    new Uint8Array([
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    ]),
  ],
  "(": [
    new Uint8Array([0xff, 0xff, 0x3f, 0xf, 0xc7, 0xf3, 0xfb, 0xfb, 0xff, 0xff]),
    new Uint8Array([
      0xff, 0xff, 0xfc, 0xf0, 0xe3, 0xcf, 0xdf, 0xdf, 0xff, 0xff,
    ]),
  ],
  ")": [
    new Uint8Array([0xff, 0xff, 0xfb, 0xfb, 0xf3, 0xc7, 0xf, 0x3f, 0xff, 0xff]),
    new Uint8Array([
      0xff, 0xff, 0xdf, 0xdf, 0xcf, 0xe3, 0xf0, 0xfc, 0xff, 0xff,
    ]),
  ],
  "*": [
    new Uint8Array([0xff, 0xdf, 0x9f, 0x3f, 0xf, 0xf, 0x3f, 0x9f, 0xdf, 0xff]),
    new Uint8Array([
      0xff, 0xfd, 0xfc, 0xfe, 0xf8, 0xf8, 0xfe, 0xfc, 0xfd, 0xff,
    ]),
  ],
  "+": [
    new Uint8Array([
      0xff, 0xff, 0x7f, 0x7f, 0x1f, 0x1f, 0x7f, 0x7f, 0xff, 0xff,
    ]),
    new Uint8Array([
      0xff, 0xff, 0xff, 0xff, 0xfc, 0xfc, 0xff, 0xff, 0xff, 0xff,
    ]),
  ],
  ",": [
    new Uint8Array([
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    ]),
    new Uint8Array([
      0xff, 0xff, 0xff, 0xdf, 0xc7, 0xe7, 0xff, 0xff, 0xff, 0xff,
    ]),
  ],
  "-": [
    new Uint8Array([
      0xff, 0xff, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0xff, 0xff,
    ]),
    new Uint8Array([
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    ]),
  ],
  ".": [
    new Uint8Array([
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    ]),
    new Uint8Array([
      0xff, 0xff, 0xff, 0xff, 0xe7, 0xe7, 0xff, 0xff, 0xff, 0xff,
    ]),
  ],
  "/": [
    new Uint8Array([
      0xff, 0xff, 0xff, 0xff, 0x7f, 0x3f, 0x9f, 0xcf, 0xe7, 0xff,
    ]),
    new Uint8Array([
      0xff, 0xf3, 0xf9, 0xfc, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff,
    ]),
  ],
  "0": [
    new Uint8Array([0xff, 0xf, 0x7, 0xf3, 0x7b, 0x3b, 0xb3, 0x7, 0xf, 0xff]),
    new Uint8Array([
      0xff, 0xf8, 0xf0, 0xe6, 0xee, 0xef, 0xe7, 0xf0, 0xf8, 0xff,
    ]),
  ],
  "1": [
    new Uint8Array([0xff, 0xff, 0xef, 0xf7, 0x3, 0x3, 0xff, 0xff, 0xff, 0xff]),
    new Uint8Array([
      0xff, 0xef, 0xef, 0xef, 0xe0, 0xe0, 0xef, 0xef, 0xef, 0xff,
    ]),
  ],
  "2": [
    new Uint8Array([
      0xff, 0xef, 0xe7, 0xf3, 0x7b, 0x7b, 0x33, 0x87, 0xcf, 0xff,
    ]),
    new Uint8Array([
      0xff, 0xe3, 0xe1, 0xec, 0xee, 0xef, 0xef, 0xe7, 0xe3, 0xff,
    ]),
  ],
  "3": [
    new Uint8Array([
      0xff, 0xff, 0xbb, 0x9b, 0xcb, 0xc3, 0x93, 0x3b, 0x7f, 0xff,
    ]),
    new Uint8Array([
      0xff, 0xfb, 0xf7, 0xe7, 0xef, 0xef, 0xe7, 0xf0, 0xf8, 0xff,
    ]),
  ],
  "4": [
    new Uint8Array([0xff, 0x7f, 0x1f, 0x87, 0xe3, 0xfb, 0x3, 0x3, 0xff, 0xff]),
    new Uint8Array([
      0xff, 0xf8, 0xf8, 0xfb, 0xfb, 0xeb, 0xe0, 0xe0, 0xeb, 0xff,
    ]),
  ],
  "5": [
    new Uint8Array([0xff, 0x3, 0x3, 0xbb, 0xdb, 0xdb, 0x9b, 0x3b, 0x7b, 0xff]),
    new Uint8Array([
      0xff, 0xfb, 0xf7, 0xe7, 0xef, 0xef, 0xe7, 0xf0, 0xf8, 0xff,
    ]),
  ],
  "6": [
    new Uint8Array([0xff, 0xf, 0x7, 0xb3, 0xdb, 0xdb, 0x93, 0x37, 0x6f, 0xff]),
    new Uint8Array([
      0xff, 0xf8, 0xf0, 0xe7, 0xef, 0xef, 0xe7, 0xf0, 0xf8, 0xff,
    ]),
  ],
  "7": [
    new Uint8Array([0xff, 0xe3, 0xf3, 0xfb, 0xfb, 0x3b, 0xb, 0xc3, 0xf3, 0xff]),
    new Uint8Array([
      0xff, 0xff, 0xff, 0xff, 0xe1, 0xe0, 0xfe, 0xff, 0xff, 0xff,
    ]),
  ],
  "8": [
    new Uint8Array([
      0xff, 0xcf, 0x87, 0x33, 0x7b, 0x7b, 0x3b, 0x83, 0xc7, 0xff,
    ]),
    new Uint8Array([
      0xff, 0xf1, 0xe0, 0xee, 0xef, 0xef, 0xe6, 0xf0, 0xf9, 0xff,
    ]),
  ],
  "9": [
    new Uint8Array([0xff, 0xf, 0x7, 0xf3, 0xfb, 0xfb, 0xf3, 0x7, 0xf, 0xff]),
    new Uint8Array([
      0xff, 0xfb, 0xf6, 0xe4, 0xed, 0xed, 0xe6, 0xf0, 0xf8, 0xff,
    ]),
  ],
  ":": [
    new Uint8Array([
      0xff, 0xff, 0xff, 0xff, 0x7f, 0x7f, 0xff, 0xff, 0xff, 0xff,
    ]),
    new Uint8Array([
      0xff, 0xff, 0xff, 0xff, 0xe6, 0xc6, 0xff, 0xff, 0xff, 0xff,
    ]),
  ],
  ";": [
    new Uint8Array([
      0xff, 0xff, 0xff, 0xff, 0x7f, 0x7f, 0xff, 0xff, 0xff, 0xff,
    ]),
    new Uint8Array([
      0xff, 0xff, 0xff, 0xdf, 0xc6, 0xe6, 0xff, 0xff, 0xff, 0xff,
    ]),
  ],
  "<": [
    new Uint8Array([
      0xff, 0xff, 0xff, 0x7f, 0xbf, 0xdf, 0xef, 0xf7, 0xff, 0xff,
    ]),
    new Uint8Array([
      0xff, 0xff, 0xff, 0xfe, 0xfc, 0xf9, 0xf3, 0xf7, 0xff, 0xff,
    ]),
  ],
  "=": [
    new Uint8Array([
      0xff, 0xff, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xff, 0xff,
    ]),
    new Uint8Array([
      0xff, 0xff, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xff, 0xff,
    ]),
  ],
  ">": [
    new Uint8Array([
      0xff, 0xff, 0xff, 0xf7, 0xe7, 0xcf, 0x9f, 0x3f, 0xff, 0xff,
    ]),
    new Uint8Array([
      0xff, 0xff, 0xff, 0xf7, 0xfb, 0xfd, 0xfe, 0xff, 0xff, 0xff,
    ]),
  ],
  "?": [
    new Uint8Array([
      0xff, 0xef, 0xe7, 0xf3, 0xfb, 0x7b, 0x33, 0x87, 0xcf, 0xff,
    ]),
    new Uint8Array([
      0xff, 0xff, 0xff, 0xff, 0xe5, 0xe4, 0xfe, 0xff, 0xff, 0xff,
    ]),
  ],
  "@": [
    new Uint8Array([0xff, 0x1f, 0xf, 0xf7, 0x3b, 0x1b, 0xdb, 0xd3, 0x7, 0xf]),
    new Uint8Array([
      0xff, 0xf8, 0xf0, 0xe7, 0xee, 0xec, 0xed, 0xec, 0xf6, 0xff,
    ]),
  ],
  A: [
    new Uint8Array([0xff, 0xff, 0xff, 0x1f, 0xe3, 0x3, 0x1f, 0xff, 0xff, 0xff]),
    new Uint8Array([
      0xff, 0xef, 0xe0, 0xed, 0xfd, 0xed, 0xe0, 0xe0, 0xef, 0xff,
    ]),
  ],
  B: [
    new Uint8Array([0xff, 0xfb, 0x3, 0x3, 0xbb, 0xbb, 0x13, 0x47, 0xef, 0xff]),
    new Uint8Array([
      0xff, 0xef, 0xe0, 0xe0, 0xef, 0xef, 0xe7, 0xf0, 0xf8, 0xff,
    ]),
  ],
  C: [
    new Uint8Array([0xff, 0xf, 0x7, 0xf3, 0xfb, 0xfb, 0xfb, 0xf7, 0xf3, 0xff]),
    new Uint8Array([
      0xff, 0xf8, 0xf0, 0xe7, 0xef, 0xef, 0xef, 0xe7, 0xf7, 0xff,
    ]),
  ],
  D: [
    new Uint8Array([0xff, 0xfb, 0x3, 0x3, 0xfb, 0xfb, 0xf3, 0x7, 0xf, 0xff]),
    new Uint8Array([
      0xff, 0xef, 0xe0, 0xe0, 0xef, 0xef, 0xe7, 0xf0, 0xf8, 0xff,
    ]),
  ],
  E: [
    new Uint8Array([0xff, 0xfb, 0x3, 0x3, 0xbb, 0xbb, 0x1b, 0xf3, 0xe3, 0xff]),
    new Uint8Array([
      0xff, 0xef, 0xe0, 0xe0, 0xef, 0xef, 0xef, 0xe7, 0xe3, 0xff,
    ]),
  ],
  F: [
    new Uint8Array([0xff, 0xfb, 0x3, 0x3, 0xbb, 0xbb, 0x1b, 0xf3, 0xe3, 0xff]),
    new Uint8Array([
      0xff, 0xef, 0xe0, 0xe0, 0xef, 0xff, 0xff, 0xff, 0xff, 0xff,
    ]),
  ],
  G: [
    new Uint8Array([0xff, 0xf, 0x7, 0xf3, 0xfb, 0xbb, 0xbb, 0x37, 0x33, 0xff]),
    new Uint8Array([
      0xff, 0xf8, 0xf0, 0xe7, 0xef, 0xef, 0xf7, 0xe0, 0xe0, 0xff,
    ]),
  ],
  H: [
    new Uint8Array([0xff, 0xfb, 0x3, 0x3, 0xbb, 0xbf, 0xbb, 0x3, 0x3, 0xfb]),
    new Uint8Array([
      0xff, 0xef, 0xe0, 0xe0, 0xef, 0xff, 0xef, 0xe0, 0xe0, 0xef,
    ]),
  ],
  I: [
    new Uint8Array([0xff, 0xfb, 0xfb, 0xfb, 0x3, 0x3, 0xfb, 0xfb, 0xfb, 0xff]),
    new Uint8Array([
      0xff, 0xef, 0xef, 0xef, 0xe0, 0xe0, 0xef, 0xef, 0xef, 0xff,
    ]),
  ],
  J: [
    new Uint8Array([0xff, 0xff, 0xfb, 0xfb, 0xfb, 0xfb, 0x3, 0x3, 0xfb, 0xff]),
    new Uint8Array([
      0xff, 0xf7, 0xef, 0xcf, 0xdf, 0xcf, 0xe0, 0xf0, 0xff, 0xff,
    ]),
  ],
  K: [
    new Uint8Array([0xff, 0xfb, 0x3, 0x3, 0xbb, 0x1f, 0x4b, 0xe3, 0xf3, 0xfb]),
    new Uint8Array([
      0xff, 0xef, 0xe0, 0xe0, 0xef, 0xfe, 0xe8, 0xe1, 0xe7, 0xef,
    ]),
  ],
  L: [
    new Uint8Array([0xff, 0xfb, 0x3, 0x3, 0xfb, 0xff, 0xff, 0xff, 0xff, 0xff]),
    new Uint8Array([
      0xff, 0xef, 0xe0, 0xe0, 0xef, 0xef, 0xef, 0xe7, 0xe3, 0xff,
    ]),
  ],
  M: [
    new Uint8Array([0xff, 0xfb, 0x3, 0x3, 0xc7, 0x1f, 0xc7, 0x3, 0x3, 0xfb]),
    new Uint8Array([
      0xff, 0xef, 0xe0, 0xe0, 0xef, 0xff, 0xef, 0xe0, 0xe0, 0xef,
    ]),
  ],
  N: [
    new Uint8Array([0xff, 0xfb, 0x3, 0x3, 0x8f, 0x3f, 0xfb, 0x3, 0x3, 0xfb]),
    new Uint8Array([
      0xff, 0xef, 0xe0, 0xe0, 0xef, 0xfe, 0xf8, 0xe0, 0xe0, 0xef,
    ]),
  ],
  O: [
    new Uint8Array([0xff, 0xf, 0x7, 0xf3, 0xfb, 0xfb, 0xf3, 0x7, 0xf, 0xff]),
    new Uint8Array([
      0xff, 0xf8, 0xf0, 0xe7, 0xef, 0xef, 0xe7, 0xf0, 0xf8, 0xff,
    ]),
  ],
  P: [
    new Uint8Array([0xff, 0xfb, 0x3, 0x3, 0xfb, 0xfb, 0xf3, 0x7, 0xf, 0xff]),
    new Uint8Array([
      0xff, 0xef, 0xe0, 0xe0, 0xed, 0xfd, 0xfc, 0xfe, 0xff, 0xff,
    ]),
  ],
  Q: [
    new Uint8Array([0xff, 0xf, 0x7, 0xf3, 0xfb, 0xfb, 0xf3, 0x7, 0xf, 0xff]),
    new Uint8Array([
      0xff, 0xf8, 0xf0, 0xe7, 0xef, 0xfb, 0xe7, 0x8c, 0x98, 0xff,
    ]),
  ],
  R: [
    new Uint8Array([0xff, 0xfb, 0x3, 0x3, 0xfb, 0xfb, 0xf3, 0x7, 0xf, 0xff]),
    new Uint8Array([
      0xff, 0xef, 0xe0, 0xe0, 0xed, 0xfd, 0xe8, 0xe6, 0xef, 0xff,
    ]),
  ],
  S: [
    new Uint8Array([
      0xff, 0xcf, 0x87, 0x33, 0x7b, 0x7b, 0x7b, 0xf7, 0xf3, 0xff,
    ]),
    new Uint8Array([
      0xff, 0xe3, 0xe7, 0xef, 0xef, 0xef, 0xe6, 0xf0, 0xf9, 0xff,
    ]),
  ],
  T: [
    new Uint8Array([0xff, 0xe3, 0xf3, 0xfb, 0x3, 0x3, 0xfb, 0xf3, 0xe3, 0xff]),
    new Uint8Array([
      0xff, 0xff, 0xff, 0xef, 0xe0, 0xe0, 0xef, 0xff, 0xff, 0xff,
    ]),
  ],
  U: [
    new Uint8Array([0xff, 0xfb, 0x3, 0x3, 0xfb, 0xff, 0xfb, 0x3, 0x3, 0xff]),
    new Uint8Array([
      0xff, 0xff, 0xf8, 0xf0, 0xe7, 0xef, 0xe7, 0xf0, 0xf8, 0xff,
    ]),
  ],
  V: [
    new Uint8Array([0xff, 0xfb, 0xc3, 0x3, 0x3b, 0xff, 0x3b, 0xc3, 0xfb, 0xff]),
    new Uint8Array([
      0xff, 0xff, 0xff, 0xfc, 0xe0, 0xe3, 0xfc, 0xff, 0xff, 0xff,
    ]),
  ],
  W: [
    new Uint8Array([0xff, 0xfb, 0x3, 0x3, 0xff, 0x3f, 0xff, 0x3, 0x3, 0xfb]),
    new Uint8Array([
      0xff, 0xff, 0xe0, 0xe0, 0xf8, 0xfe, 0xf8, 0xe0, 0xe0, 0xff,
    ]),
  ],
  X: [
    new Uint8Array([
      0xff, 0xfb, 0xe3, 0x83, 0x1b, 0x7f, 0x9b, 0xe3, 0xfb, 0xff,
    ]),
    new Uint8Array([
      0xff, 0xef, 0xe3, 0xec, 0xff, 0xec, 0xe0, 0xe3, 0xef, 0xff,
    ]),
  ],
  Y: [
    new Uint8Array([0xff, 0xfb, 0xc3, 0x3, 0x3b, 0xff, 0x3b, 0xc3, 0xfb, 0xff]),
    new Uint8Array([
      0xff, 0xff, 0xff, 0xff, 0xe0, 0xe0, 0xff, 0xff, 0xff, 0xff,
    ]),
  ],
  Z: [
    new Uint8Array([
      0xff, 0xe3, 0xf3, 0xfb, 0x7b, 0x1b, 0x83, 0xe3, 0xfb, 0xff,
    ]),
    new Uint8Array([
      0xff, 0xef, 0xe3, 0xe0, 0xec, 0xef, 0xef, 0xe7, 0xe3, 0xff,
    ]),
  ],
  "[": [
    new Uint8Array([0xff, 0xff, 0x3, 0x3, 0xfb, 0xfb, 0xfb, 0xfb, 0xff, 0xff]),
    new Uint8Array([
      0xff, 0xff, 0xe0, 0xe0, 0xef, 0xef, 0xef, 0xef, 0xff, 0xff,
    ]),
  ],
  "\\": [
    new Uint8Array([
      0xff, 0xe7, 0xcf, 0x9f, 0x3f, 0x7f, 0xff, 0xff, 0xff, 0xff,
    ]),
    new Uint8Array([
      0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfc, 0xf9, 0xf3, 0xff,
    ]),
  ],
  "]": [
    new Uint8Array([0xff, 0xff, 0xfb, 0xfb, 0xfb, 0xfb, 0x3, 0x3, 0xff, 0xff]),
    new Uint8Array([
      0xff, 0xff, 0xef, 0xef, 0xef, 0xef, 0xe0, 0xe0, 0xff, 0xff,
    ]),
  ],
  "^": [
    new Uint8Array([
      0xff, 0xdf, 0xef, 0xf7, 0xfb, 0xf3, 0xe7, 0xcf, 0xdf, 0xff,
    ]),
    new Uint8Array([
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    ]),
  ],
  _: [
    new Uint8Array([
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    ]),
    new Uint8Array([
      0xff, 0xef, 0xef, 0xef, 0xef, 0xef, 0xef, 0xef, 0xef, 0xff,
    ]),
  ],
  "`": [
    new Uint8Array([
      0xff, 0xff, 0xff, 0xfb, 0xf3, 0xe7, 0xdf, 0xff, 0xff, 0xff,
    ]),
    new Uint8Array([
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    ]),
  ],
  a: [
    new Uint8Array([
      0xff, 0xff, 0x7f, 0x3f, 0xbf, 0xbf, 0x7f, 0x3f, 0x3f, 0xff,
    ]),
    new Uint8Array([
      0xff, 0xf8, 0xf0, 0xe7, 0xef, 0xef, 0xe7, 0xf0, 0xe0, 0xef,
    ]),
  ],
  b: [
    new Uint8Array([0xff, 0xfb, 0x3, 0x3, 0x7f, 0xbf, 0xbf, 0x3f, 0x7f, 0xff]),
    new Uint8Array([
      0xff, 0xef, 0xe0, 0xf0, 0xe7, 0xef, 0xef, 0xe7, 0xf0, 0xf8,
    ]),
  ],
  c: [
    new Uint8Array([
      0xff, 0xff, 0x7f, 0x3f, 0xbf, 0xbf, 0xbf, 0x7f, 0x3f, 0xff,
    ]),
    new Uint8Array([
      0xff, 0xf8, 0xf0, 0xe7, 0xef, 0xef, 0xef, 0xe7, 0xf7, 0xff,
    ]),
  ],
  d: [
    new Uint8Array([0xff, 0xff, 0x7f, 0x3f, 0xbf, 0xbf, 0x7f, 0x3, 0x3, 0xfb]),
    new Uint8Array([
      0xff, 0xf8, 0xf0, 0xe7, 0xef, 0xef, 0xe7, 0xf0, 0xe0, 0xef,
    ]),
  ],
  e: [
    new Uint8Array([
      0xff, 0xff, 0x7f, 0x3f, 0xbf, 0xbf, 0xbf, 0x3f, 0x7f, 0xff,
    ]),
    new Uint8Array([
      0xff, 0xf8, 0xf0, 0xe5, 0xed, 0xed, 0xed, 0xe4, 0xf6, 0xff,
    ]),
  ],
  f: [
    new Uint8Array([0xff, 0xbf, 0xf, 0x7, 0xb3, 0xbb, 0xbb, 0xf3, 0xf7, 0xff]),
    new Uint8Array([
      0xff, 0xef, 0xe0, 0xe0, 0xef, 0xff, 0xff, 0xff, 0xff, 0xff,
    ]),
  ],
  g: [
    new Uint8Array([
      0xff, 0xff, 0x7f, 0x3f, 0xbf, 0xbf, 0x7f, 0x3f, 0x3f, 0xff,
    ]),
    new Uint8Array([
      0xff, 0xec, 0xc8, 0x93, 0xb7, 0xb7, 0x93, 0xc0, 0xe0, 0xff,
    ]),
  ],
  h: [
    new Uint8Array([0xff, 0xfb, 0x3, 0x3, 0x7f, 0xbf, 0xbf, 0x3f, 0x7f, 0xff]),
    new Uint8Array([
      0xff, 0xef, 0xe0, 0xe0, 0xef, 0xff, 0xef, 0xe0, 0xe0, 0xef,
    ]),
  ],
  i: [
    new Uint8Array([
      0xff, 0xff, 0xbf, 0xbf, 0x27, 0x27, 0xff, 0xff, 0xff, 0xff,
    ]),
    new Uint8Array([
      0xff, 0xef, 0xef, 0xef, 0xe0, 0xe0, 0xef, 0xef, 0xef, 0xff,
    ]),
  ],
  j: [
    new Uint8Array([
      0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 0xbf, 0x27, 0x27, 0xff,
    ]),
    new Uint8Array([
      0xff, 0xef, 0xcf, 0x9f, 0xbf, 0xbf, 0x9f, 0xc0, 0xe0, 0xff,
    ]),
  ],
  k: [
    new Uint8Array([0xff, 0xfb, 0x3, 0x3, 0xfb, 0xbf, 0x3f, 0x3f, 0xbf, 0xff]),
    new Uint8Array([
      0xff, 0xef, 0xe0, 0xe0, 0xed, 0xf8, 0xe2, 0xe7, 0xef, 0xff,
    ]),
  ],
  l: [
    new Uint8Array([0xff, 0xff, 0xfb, 0xfb, 0x3, 0x3, 0xff, 0xff, 0xff, 0xff]),
    new Uint8Array([
      0xff, 0xef, 0xef, 0xef, 0xe0, 0xe0, 0xef, 0xef, 0xef, 0xff,
    ]),
  ],
  m: [
    new Uint8Array([
      0xbf, 0x3f, 0x7f, 0x3f, 0x3f, 0x7f, 0x3f, 0x3f, 0x7f, 0xff,
    ]),
    new Uint8Array([
      0xef, 0xe0, 0xe0, 0xff, 0xe0, 0xe0, 0xff, 0xe0, 0xe0, 0xef,
    ]),
  ],
  n: [
    new Uint8Array([
      0xff, 0xbf, 0x3f, 0x3f, 0x7f, 0xbf, 0xbf, 0x3f, 0x7f, 0xff,
    ]),
    new Uint8Array([
      0xff, 0xef, 0xe0, 0xe0, 0xef, 0xff, 0xef, 0xe0, 0xe0, 0xef,
    ]),
  ],
  o: [
    new Uint8Array([
      0xff, 0xff, 0x7f, 0x3f, 0xbf, 0xbf, 0x3f, 0x7f, 0xff, 0xff,
    ]),
    new Uint8Array([
      0xff, 0xf8, 0xf0, 0xe7, 0xef, 0xef, 0xe7, 0xf0, 0xf8, 0xff,
    ]),
  ],
  p: [
    new Uint8Array([
      0xff, 0x3f, 0x3f, 0x7f, 0xbf, 0xbf, 0x3f, 0x7f, 0xff, 0xff,
    ]),
    new Uint8Array([
      0xff, 0x80, 0x80, 0xdb, 0xf7, 0xf7, 0xf3, 0xf8, 0xfc, 0xff,
    ]),
  ],
  q: [
    new Uint8Array([
      0xff, 0xff, 0x7f, 0x3f, 0xbf, 0xbf, 0x7f, 0x3f, 0x3f, 0xff,
    ]),
    new Uint8Array([
      0xff, 0xfc, 0xf8, 0xf3, 0xf7, 0xf7, 0xfb, 0x80, 0x80, 0xdf,
    ]),
  ],
  r: [
    new Uint8Array([
      0xff, 0xbf, 0x3f, 0x3f, 0x7f, 0xbf, 0xbf, 0x3f, 0x7f, 0xff,
    ]),
    new Uint8Array([
      0xff, 0xef, 0xe0, 0xe0, 0xef, 0xff, 0xff, 0xff, 0xff, 0xff,
    ]),
  ],
  s: [
    new Uint8Array([
      0xff, 0x7f, 0x3f, 0xbf, 0xbf, 0xbf, 0xbf, 0x7f, 0x3f, 0xff,
    ]),
    new Uint8Array([
      0xff, 0xf6, 0xe4, 0xed, 0xed, 0xed, 0xed, 0xe1, 0xf3, 0xff,
    ]),
  ],
  t: [
    new Uint8Array([0xff, 0xbf, 0x3, 0x3, 0xbf, 0xbf, 0xbf, 0xff, 0xff, 0xff]),
    new Uint8Array([
      0xff, 0xff, 0xf0, 0xe0, 0xef, 0xef, 0xef, 0xe7, 0xf7, 0xff,
    ]),
  ],
  u: [
    new Uint8Array([
      0xff, 0xbf, 0x3f, 0x3f, 0xff, 0xff, 0xff, 0x3f, 0x3f, 0xff,
    ]),
    new Uint8Array([
      0xff, 0xff, 0xf0, 0xe0, 0xef, 0xef, 0xef, 0xf0, 0xe0, 0xef,
    ]),
  ],
  v: [
    new Uint8Array([
      0xff, 0xbf, 0x3f, 0x3f, 0xbf, 0xff, 0xff, 0xbf, 0x3f, 0xbf,
    ]),
    new Uint8Array([
      0xff, 0xff, 0xfe, 0xf8, 0xe1, 0xe7, 0xe7, 0xf9, 0xfe, 0xff,
    ]),
  ],
  w: [
    new Uint8Array([
      0xff, 0xbf, 0x3f, 0x3f, 0xff, 0x3f, 0x3f, 0xff, 0x3f, 0xbf,
    ]),
    new Uint8Array([
      0xff, 0xff, 0xfc, 0xe0, 0xe3, 0xfc, 0xe0, 0xe3, 0xfc, 0xff,
    ]),
  ],
  x: [
    new Uint8Array([
      0xff, 0xbf, 0x3f, 0x3f, 0xbf, 0xff, 0xbf, 0x3f, 0xbf, 0xff,
    ]),
    new Uint8Array([
      0xff, 0xef, 0xe7, 0xea, 0xfc, 0xe9, 0xe2, 0xe7, 0xef, 0xff,
    ]),
  ],
  y: [
    new Uint8Array([
      0xff, 0xbf, 0x3f, 0x3f, 0xbf, 0xff, 0xbf, 0x3f, 0x3f, 0xbf,
    ]),
    new Uint8Array([
      0xff, 0xff, 0xec, 0xc8, 0x93, 0xb7, 0x9b, 0xc0, 0xe0, 0xff,
    ]),
  ],
  z: [
    new Uint8Array([
      0xff, 0x3f, 0xbf, 0xbf, 0xbf, 0xbf, 0x3f, 0x3f, 0xbf, 0xff,
    ]),
    new Uint8Array([
      0xff, 0xef, 0xe7, 0xe3, 0xe9, 0xec, 0xee, 0xef, 0xe7, 0xff,
    ]),
  ],
  "{": [
    new Uint8Array([0xff, 0xff, 0x7f, 0xf, 0x87, 0xf3, 0xfb, 0xfb, 0xff, 0xff]),
    new Uint8Array([
      0xff, 0xff, 0xff, 0xf8, 0xf0, 0xe7, 0xef, 0xef, 0xff, 0xff,
    ]),
  ],
  "|": [
    new Uint8Array([
      0xff, 0xff, 0xff, 0xff, 0x83, 0x83, 0xff, 0xff, 0xff, 0xff,
    ]),
    new Uint8Array([
      0xff, 0xff, 0xff, 0xff, 0xe0, 0xe0, 0xff, 0xff, 0xff, 0xff,
    ]),
  ],
  "}": [
    new Uint8Array([0xff, 0xff, 0xfb, 0xfb, 0xf3, 0x87, 0xf, 0x7f, 0xff, 0xff]),
    new Uint8Array([
      0xff, 0xff, 0xef, 0xef, 0xe7, 0xf0, 0xf8, 0xff, 0xff, 0xff,
    ]),
  ],
  "~": [
    new Uint8Array([
      0xff, 0xff, 0x7f, 0x3f, 0x3f, 0x7f, 0x7f, 0x7f, 0xbf, 0xff,
    ]),
    new Uint8Array([
      0xff, 0xfe, 0xff, 0xff, 0xff, 0xfe, 0xfe, 0xff, 0xff, 0xff,
    ]),
  ],
};

/**
 * Indicates a side of the controller, for distinguishing controls and lights
 * which are repeated on both sides of the controller.
 */
type Side = "left" | "right";

/**
 * Provides a convenient interface to retrieve data from an input message.
 */
class InputMessage {
  private data: Uint8Array;

  private constructor(data: Uint8Array) {
    this.data = data;
  }

  /** Checks that value is a valid input message and constructs an object for it. */
  static load(data: Uint8Array): InputMessage {
    if (data[0] !== 0x01) {
      throw new Error(`Invalid message ID 0x${data[0].toString(16)}`);
    }
    if (data.length !== 35) {
      throw new Error(`Invalid message length ${data.length}`);
    }
    return new InputMessage(data);
  }

  /**
   * Indicates that is the default null message which is loaded before any
   * input has been received.
   */
  isNull(): boolean {
    return this.data === NULL_INPUT;
  }

  /** EQ mode switch button status for a side */
  eqModeSwitch(side: Side): boolean {
    switch (side) {
      case "left":
        return !!(this.data[1] & 0x01);
      case "right":
        return !!(this.data[1] & 0x08);
    }
  }

  /** Stems mode switch button status for a side */
  stemsModeSwitch(side: Side): boolean {
    switch (side) {
      case "left":
        return !!(this.data[1] & 0x02);
      case "right":
        return !!(this.data[1] & 0x10);
    }
  }

  /** Decks toggle switch button status */
  decksAbCdToggle(): boolean {
    return !!(this.data[1] & 0x04);
  }

  /** FX toggle button status for a side */
  fxToggle(side: Side): boolean {
    switch (side) {
      case "left":
        return !!(this.data[1] & 0x20);
      case "right":
        return !!(this.data[1] & 0x40);
    }
  }

  /** FX switch button status */
  fxSwitch(number: number): boolean {
    switch (number) {
      case 1:
        return !!(this.data[1] & 0x80);
      case 2:
        return !!(this.data[2] & 0x01);
      case 3:
        return !!(this.data[2] & 0x02);
      case 4:
        return !!(this.data[2] & 0x04);
      case 5:
        return !!(this.data[2] & 0x08);
      default:
        return false;
    }
  }

  /** Prelisten toggle button status for a side */
  prelistenToggle(side: Side): boolean {
    switch (side) {
      case "left":
        return !!(this.data[2] & 0x10);
      case "right":
        return !!(this.data[2] & 0x20);
    }
  }

  /** Gain knob for a side, scaled to 0-1 */
  gain(side: Side): number {
    switch (side) {
      case "left":
        return (this.data[3] | (this.data[4] << 8)) / INPUT_NUMBER_MAX;
      case "right":
        return (this.data[13] | (this.data[14] << 8)) / INPUT_NUMBER_MAX;
    }
  }

  /** Hi knob for a side, scaled to 0-1 */
  hi(side: Side): number {
    switch (side) {
      case "left":
        return (this.data[5] | (this.data[6] << 8)) / INPUT_NUMBER_MAX;
      case "right":
        return (this.data[15] | (this.data[16] << 8)) / INPUT_NUMBER_MAX;
    }
  }

  /** Mid knob for a side, scaled to 0-1 */
  mid(side: Side): number {
    switch (side) {
      case "left":
        return (this.data[7] | (this.data[8] << 8)) / INPUT_NUMBER_MAX;
      case "right":
        return (this.data[17] | (this.data[18] << 8)) / INPUT_NUMBER_MAX;
    }
  }

  /** Low knob for a side, scaled to 0-1 */
  low(side: Side): number {
    switch (side) {
      case "left":
        return (this.data[9] | (this.data[10] << 8)) / INPUT_NUMBER_MAX;
      case "right":
        return (this.data[19] | (this.data[20] << 8)) / INPUT_NUMBER_MAX;
    }
  }

  /** FX knob for a side, scaled to 0-1 */
  fx(side: Side): number {
    switch (side) {
      case "left":
        return (this.data[11] | (this.data[12] << 8)) / INPUT_NUMBER_MAX;
      case "right":
        return (this.data[21] | (this.data[22] << 8)) / INPUT_NUMBER_MAX;
    }
  }

  /** Headphone mix, scaled to 0-1 */
  headphonesMix(): number {
    return (this.data[23] | (this.data[24] << 8)) / INPUT_NUMBER_MAX;
  }

  /** Main volume, scaled to 0-1 */
  mainVolume(): number {
    return (this.data[25] | (this.data[26] << 8)) / INPUT_NUMBER_MAX;
  }

  /** Headphone volume, scaled to 0-1 */
  headphonesVolume(): number {
    return (this.data[27] | (this.data[28] << 8)) / INPUT_NUMBER_MAX;
  }

  /** Fader position, scaled to 0-1 */
  fader(side: Side): number {
    switch (side) {
      case "left":
        return (this.data[29] | (this.data[30] << 8)) / INPUT_NUMBER_MAX;
      case "right":
        return (this.data[31] | (this.data[32] << 8)) / INPUT_NUMBER_MAX;
    }
  }

  /** Crossfader position, scaled to 0-1 */
  crossfader(): number {
    return (this.data[33] | (this.data[34] << 8)) / INPUT_NUMBER_MAX;
  }
}

/** Represents an RGB color code which can be displayed by a light. */
type Color =
  | "black"
  | "red"
  | "redDim"
  | "darkOrange"
  | "darkOrangeDim"
  | "lightOrange"
  | "lightOrangeDim"
  | "warmOrange"
  | "warmOrangeDim"
  | "warmYellow"
  | "yellow"
  | "yellowDim"
  | "lime"
  | "limeDim"
  | "green"
  | "greenDim"
  | "mint"
  | "mintDim"
  | "cyan"
  | "cyanDim"
  | "turquoise"
  | "turquoiseDim"
  | "blue"
  | "blueDim"
  | "plum"
  | "plumDim"
  | "violet"
  | "violetDim"
  | "purple"
  | "purpleDim"
  | "magenta"
  | "magentaDim"
  | "fuschiaDark"
  | "fuschia"
  | "white";

const COLOR_CODES: Record<Color, number> = {
  black: 0x00,
  redDim: 0x04,
  red: 0x06,
  darkOrangeDim: 0x08,
  darkOrange: 0x0a,
  lightOrangeDim: 0x0c,
  lightOrange: 0x0e,
  warmOrangeDim: 0x10,
  warmOrange: 0x12,
  yellowDim: 0x14,
  yellow: 0x16,
  limeDim: 0x18,
  lime: 0x1a,
  greenDim: 0x1c,
  green: 0x1e,
  mintDim: 0x20,
  mint: 0x22,
  cyanDim: 0x24,
  cyan: 0x26,
  turquoiseDim: 0x28,
  turquoise: 0x2a,
  blueDim: 0x2c,
  blue: 0x2e,
  plumDim: 0x30,
  plum: 0x32,
  violetDim: 0x34,
  violet: 0x36,
  purpleDim: 0x38,
  purple: 0x3a,
  magentaDim: 0x3c,
  magenta: 0x3e,
  fuschiaDark: 0x40,
  fuschia: 0x42,
  white: 0x46,
  warmYellow: 0x12,
};

const DIM_COLORS: Record<Color, Color> = {
  black: "black",
  redDim: "redDim",
  red: "redDim",
  darkOrangeDim: "darkOrangeDim",
  darkOrange: "darkOrangeDim",
  lightOrangeDim: "lightOrangeDim",
  lightOrange: "lightOrangeDim",
  warmOrangeDim: "warmOrangeDim",
  warmOrange: "warmOrangeDim",
  warmYellow: "warmOrangeDim",
  yellowDim: "yellowDim",
  yellow: "yellowDim",
  limeDim: "limeDim",
  lime: "limeDim",
  greenDim: "greenDim",
  green: "greenDim",
  mintDim: "mintDim",
  mint: "mintDim",
  cyanDim: "cyanDim",
  cyan: "cyanDim",
  turquoiseDim: "turquoiseDim",
  turquoise: "turquoiseDim",
  blueDim: "blueDim",
  blue: "blueDim",
  plumDim: "plumDim",
  plum: "plumDim",
  violetDim: "violetDim",
  violet: "violetDim",
  purpleDim: "purpleDim",
  purple: "purpleDim",
  magentaDim: "magentaDim",
  magenta: "magentaDim",
  fuschiaDark: "fuschiaDark",
  fuschia: "fuschiaDark",
  white: "white",
};

type ColorConfig = {
  theme: Color;
  eqSwitch: Color | "default";
  stemsSwitch: Color | "default";
  fx: Color[];
  prelistenToggle: Color | "default";
  bottomLedsDefault: Color | "default";
  bottomLeds: (Color | "default")[];
};

const DEFAULT_COLOR_CONFIG: ColorConfig = {
  theme: "lightOrange",
  eqSwitch: "default",
  stemsSwitch: "default",
  fx: ["red", "green", "blue", "magenta", "darkOrange"],
  prelistenToggle: "default",
  bottomLedsDefault: "default",
  bottomLeds: [
    "default",
    "default",
    "default",
    "default",
    "default",
    "default",
  ],
};

/** Provides a convenient interface to store light status and send it to the controller. */
class LightsStatus {
  vuLevel: Record<Side, number> = { left: 0, right: 0 };
  eqModeSwitch: Record<Side, Color> = { left: "black", right: "black" };
  stemsModeSwitch: Record<Side, Color> = { left: "black", right: "black" };
  fxToggle: Record<Side, Color> = { left: "black", right: "black" };
  fxSwitches: Color[] = ["black", "black", "black", "black"];
  fxFilterSwitch: Color = "black";
  prelistenToggle: Record<Side, Color> = { left: "black", right: "black" };
  bottomLeds: Record<Side, Color[]> = {
    left: ["black", "black", "black", "black", "black", "black"],
    right: ["black", "black", "black", "black", "black", "black"],
  };

  clear() {
    this.vuLevel = { left: 0, right: 0 };
    this.eqModeSwitch = { left: "black", right: "black" };
    this.stemsModeSwitch = { left: "black", right: "black" };
    this.fxToggle = { left: "black", right: "black" };
    this.fxSwitches = ["black", "black", "black", "black"];
    this.fxFilterSwitch = "black";
    this.prelistenToggle = { left: "black", right: "black" };
    this.bottomLeds = {
      left: ["black", "black", "black", "black", "black", "black"],
      right: ["black", "black", "black", "black", "black", "black"],
    };
  }

  toMessage(): Uint8Array {
    const message = new Uint8Array(47);

    // Message ID
    message[0] = 0x80;

    // VU Meter Left (bytes 1-10)
    for (let i = 0; i < 10; i++) {
      message[1 + i] = i < this.vuLevel.left ? 0x7e : 0x00;
    }

    // VU Meter Right (bytes 11-20)
    for (let i = 0; i < 10; i++) {
      message[11 + i] = i < this.vuLevel.right ? 0x7e : 0x00;
    }

    // EQ Mode Switch Left
    message[21] = COLOR_CODES[this.eqModeSwitch.left];

    // Stems Mode Switch Left
    message[22] = COLOR_CODES[this.stemsModeSwitch.left];

    // Unused (byte 23)
    message[23] = 0x00;

    // EQ Mode Switch Right
    message[24] = COLOR_CODES[this.eqModeSwitch.right];

    // Stems Mode Switch Right
    message[25] = COLOR_CODES[this.stemsModeSwitch.right];

    // FX Toggle Left
    message[26] = COLOR_CODES[this.fxToggle.left];

    // FX Toggle Right
    message[27] = COLOR_CODES[this.fxToggle.right];

    // FX Switches
    for (var i = 0; i < 4; i++) {
      message[28 + i] = COLOR_CODES[this.fxSwitches[i]];
    }

    // FX Filter Switch
    message[32] = COLOR_CODES[this.fxFilterSwitch];

    // Prelisten Toggle Left
    message[33] = COLOR_CODES[this.prelistenToggle.left];

    // Prelisten Toggle Right
    message[34] = COLOR_CODES[this.prelistenToggle.right];

    // Bottom LEDs Left (bytes 35-40)
    for (let i = 0; i < 6; i++) {
      message[35 + i] = COLOR_CODES[this.bottomLeds.left[i]];
    }

    // Bottom LEDs Right (bytes 41-46)
    for (let i = 0; i < 6; i++) {
      message[41 + i] = COLOR_CODES[this.bottomLeds.right[i]];
    }

    return message;
  }

  send() {
    controller.sendOutputReport(0, this.toMessage().buffer as ArrayBuffer);
  }
}

const dumpMessageForDebug = (message: Uint8Array): void => {
  let debugMessage = Array.from(message)
    .map((x) => x.toString(16).padStart(2, "0").toUpperCase())
    .join(" ");
  console.debug(`Message (${message.length} bytes):\n${debugMessage}`);
};

const SCREEN_ROWS_COUNT = 8;
const SCREEN_WIDTH = 128;
const SCREEN_UPDATE_COOLDOWN_MS = 50;

/** Class to handle drawing to a screen. */
class ScreenData {
  rows: Uint8Array[] = [];
  screenId: number;
  hasChanges = false;
  onCooldown = false;

  constructor(screenId: number) {
    this.screenId = screenId;
    for (let i = 0; i < SCREEN_ROWS_COUNT; i++) {
      this.rows.push(new Uint8Array(SCREEN_WIDTH));
    }
    this.clear();
  }

  clear() {
    for (const row of this.rows) {
      for (let i = 0; i < SCREEN_WIDTH; i++) {
        row[i] = 0xff;
      }
    }
    this.hasChanges = true;
  }

  /**
   * Writes text do the display, wrapping if necessary. Wrapping can break anywhere
   * in the word, not just within whitespace. If there is too much text to fit within
   * the allowed space, it will be truncated.
   *
   * Any characters not contained in the font dataset will be replaced with a "~"
   *
   * @param text The text to write to the display.
   * @param left Left margin for the text from the left of the screen, in characters.
   * @param top Top margin for the text from the top of the screen, in characters.
   * @param right Right margin for the text from the right of the screen, in characters.
   * @param bottom Bottom margin for the text from the bottom of the screen, in characters.
   */
  writeText(
    text: string,
    left: number,
    top: number,
    right: number,
    bottom: number,
  ) {
    // Calculate available space in pixels
    const availableWidth = SCREEN_WIDTH / FONT_CHAR_WIDTH - left - right;
    const availableHeight =
      (SCREEN_ROWS_COUNT * 8) / FONT_CHAR_HEIGHT - top - bottom;

    if (availableWidth <= 0 || availableHeight <= 0) {
      return; // No space to write
    }

    let currentX = left;
    let currentY = top;

    for (let i = 0; i < text.length && currentY < top + availableHeight; i++) {
      let char = text[i];

      // Replace unknown characters with ~
      if (!(char in FONT_DATA)) {
        char = "~";
      }

      // Check if we need to wrap to next line
      if (currentX >= left + availableWidth) {
        currentX = left;
        currentY++;
        if (currentY >= top + availableHeight) {
          break; // Out of vertical space
        }
      }

      // Get font data for this character
      const [topSection, bottomSection] = FONT_DATA[char];

      // Calculate pixel positions
      const pixelX = currentX * FONT_CHAR_WIDTH;
      const pixelY = currentY * FONT_CHAR_HEIGHT;

      // Render character to screen buffer
      for (let col = 0; col < FONT_CHAR_WIDTH; col++) {
        const screenCol = pixelX + col;
        if (screenCol >= SCREEN_WIDTH) break;

        // Top half (first 8 rows of character)
        const topRowStart = Math.floor(pixelY / 8);
        if (topRowStart < SCREEN_ROWS_COUNT) {
          this.rows[topRowStart][screenCol] = topSection[col];
        }

        // Bottom half (second 8 rows of character)
        const bottomRowStart = Math.floor((pixelY + 8) / 8);
        if (bottomRowStart < SCREEN_ROWS_COUNT) {
          this.rows[bottomRowStart][screenCol] = bottomSection[col];
        }
      }
      currentX++;
    }
    this.hasChanges = true;
  }

  /**
   * Writes text do the display, at double the normal size. This will work in the
   * same way as writeText, but every pixel is doubled in size. The margins are
   * still specified as small sized characters, not doubles.
   *
   * @param text The text to write to the display.
   * @param left Left margin for the text from the left of the screen, in characters.
   * @param top Top margin for the text from the top of the screen, in characters.
   * @param right Right margin for the text from the right of the screen, in characters.
   * @param bottom Bottom margin for the text from the bottom of the screen, in characters.
   */
  writeTextBig(
    text: string,
    left: number,
    top: number,
    right: number,
    bottom: number,
  ) {
    const scale = 2;
    const scaledCharWidth = FONT_CHAR_WIDTH * scale;
    const scaledCharHeight = FONT_CHAR_HEIGHT * scale;

    // Calculate available space in characters (accounting for scaling)
    const availableWidthChars = Math.floor(
      (SCREEN_WIDTH - left * scaledCharWidth - right * scaledCharWidth) /
        scaledCharWidth,
    );
    const availableHeightChars = Math.floor(
      (SCREEN_ROWS_COUNT * 8 -
        top * scaledCharHeight -
        bottom * scaledCharHeight) /
        scaledCharHeight,
    );

    if (availableWidthChars <= 0 || availableHeightChars <= 0) {
      return; // No space to write
    }

    let currentX = 0;
    let currentY = 0;

    for (let i = 0; i < text.length && currentY < availableHeightChars; i++) {
      let char = text[i];

      // Replace unknown characters with ~
      if (!(char in FONT_DATA)) {
        char = "~";
      }

      // Check if we need to wrap to next line
      if (currentX >= availableWidthChars) {
        currentX = 0;
        currentY++;
        if (currentY >= availableHeightChars) {
          break; // Out of vertical space
        }
      }

      // Get font data for this character
      const [topSection, bottomSection] = FONT_DATA[char];

      // Calculate pixel positions
      const pixelX = left * scaledCharWidth + currentX * scaledCharWidth;
      const pixelY = top * scaledCharHeight + currentY * scaledCharHeight;

      // Render scaled character to screen buffer
      for (let fontCol = 0; fontCol < FONT_CHAR_WIDTH; fontCol++) {
        for (let scaleX = 0; scaleX < scale; scaleX++) {
          const screenCol = pixelX + fontCol * scale + scaleX;
          if (screenCol >= SCREEN_WIDTH) break;

          // Process top half of character (first 8 rows)
          for (let fontRow = 0; fontRow < 8; fontRow++) {
            const fontPixel = (topSection[fontCol] >> fontRow) & 1;

            for (let scaleY = 0; scaleY < scale; scaleY++) {
              const screenRowPixel = pixelY + fontRow * scale + scaleY;
              const screenRow = Math.floor(screenRowPixel / 8);
              const pixelInRow = screenRowPixel % 8;

              if (screenRow < SCREEN_ROWS_COUNT) {
                if (fontPixel === 0) {
                  // Set pixel (font data is inverted - 0 means draw)
                  this.rows[screenRow][screenCol] &= ~(1 << pixelInRow);
                } else {
                  // Clear pixel
                  this.rows[screenRow][screenCol] |= 1 << pixelInRow;
                }
              }
            }
          }

          // Process bottom half of character (second 8 rows)
          for (let fontRow = 0; fontRow < 8; fontRow++) {
            const fontPixel = (bottomSection[fontCol] >> fontRow) & 1;

            for (let scaleY = 0; scaleY < scale; scaleY++) {
              const screenRowPixel = pixelY + (8 + fontRow) * scale + scaleY;
              const screenRow = Math.floor(screenRowPixel / 8);
              const pixelInRow = screenRowPixel % 8;

              if (screenRow < SCREEN_ROWS_COUNT) {
                if (fontPixel === 0) {
                  // Set pixel (font data is inverted - 0 means draw)
                  this.rows[screenRow][screenCol] &= ~(1 << pixelInRow);
                } else {
                  // Clear pixel
                  this.rows[screenRow][screenCol] |= 1 << pixelInRow;
                }
              }
            }
          }
        }
      }
      currentX++;
    }
    this.hasChanges = true;
  }

  /**
   * Sends the screen data to the controller using the screen protocol.
   * Sends data in pairs of rows (0-1, 2-3, 4-5, 6-7) as per the protocol spec.
   */
  send() {
    if (this.onCooldown) return;
    this.hasChanges = false;

    // Set a delay to prevent rapid resending of the screen
    this.onCooldown = true;
    engine.beginTimer(
      SCREEN_UPDATE_COOLDOWN_MS,
      () => {
        this.onCooldown = false;
        if (this.hasChanges) {
          this.send();
        }
      },
      true,
    );

    // Screen message IDs: 0xE0 (left), 0xE1 (center), 0xE2 (right)
    const messageId = 0xe0 + this.screenId;

    // Send data in pairs of rows
    for (let rowPair = 0; rowPair < SCREEN_ROWS_COUNT / 2; rowPair++) {
      const message = new Uint8Array(272);

      // Header
      message[0] = 0x00;
      message[1] = 0x00;
      message[2] = rowPair * 2;
      message[3] = 0x00;
      message[4] = 0x80; // Size of pixel data
      message[5] = 0x00;
      message[6] = 0x02; // Number of rows
      message[7] = 0x00;

      // Pixel data - 2 rows of 64 pixels each
      const row1 = rowPair * 2;
      const row2 = rowPair * 2 + 1;

      // Copy rows to buffer
      for (let col = 0; col < SCREEN_WIDTH; col++) {
        message[8 + col] =
          row1 < SCREEN_ROWS_COUNT ? this.rows[row1][col] : 0xff;
        message[8 + SCREEN_WIDTH + col] =
          row2 < SCREEN_ROWS_COUNT ? this.rows[row2][col] : 0xff;
      }

      // Send the message
      dumpMessageForDebug(message);
      controller.sendOutputReport(
        messageId,
        message.buffer as ArrayBuffer,
        true, // Need to disable auto-skipping as we're sending multiple reports with the same ID in quick succession
      );
    }
  }
}

const mappings = [
  {
    channel: "[Channel1]",
    side: "left" as const,
  },
  {
    channel: "[Channel2]",
    side: "right" as const,
  },
];

/**
 * Scales a value from 0-1 into a value from 0-4, for use as a gain value. Values < 0.5 are
 * linearly mapped to 0-1, and 0.5-1 are mapped to 1-4. */
const scaleToGain = (value: number): number => {
  if (value < 0.5) {
    return value * 2;
  } else {
    return (value - 0.5) * 6 + 1;
  }
};

/** Scales a value from 0-1 into a value from -1-1 for use as a crossfade value. */
const scaleToCrossfade = (value: number): number => {
  return value * 2 - 1;
};

type ChangeDescription = {
  label: string;
  value: string;
};

type ChangeDescriptions = Record<Side | "main", ChangeDescription | undefined>;

/** Processes a change in input and updates the engine. */
const updateEngineFromInput = (
  input: InputMessage,
  oldInput: InputMessage,
  isDebugging: boolean,
): {
  lightsChanged: boolean;
  changeDescriptions: ChangeDescriptions;
} => {
  let lightsChanged = false;
  const changeDescriptions: ChangeDescriptions = {
    left: undefined,
    main: undefined,
    right: undefined,
  };

  const buttonWasPressed = (fn: (input: InputMessage) => boolean): boolean => {
    return fn(input) && !fn(oldInput);
  };
  const handleValueChange = (
    side: Side | "main",
    label: string,
    getValue: (input: InputMessage) => number,
    setValue: (value: number) => void,
  ) => {
    const oldValue = getValue(oldInput);
    const value = getValue(input);
    if (!oldInput.isNull() && value !== oldValue) {
      setValue(value);
      changeDescriptions[side] = {
        label,
        value: `${Math.round(value * 100)}%`,
      };
    }
  };
  const toggleBoolean = (group: string, name: string): void => {
    const value = engine.getValue(group, name);
    engine.setValue(group, name, value === 0 ? 1 : 0);
    lightsChanged = true;
  };

  // Handle center knobs and sliders
  handleValueChange(
    "main",
    "Main",
    (input) => input.mainVolume(),
    (value) => {
      engine.setValue("[Master]", "gain", scaleToGain(value));
    },
  );
  handleValueChange(
    "main",
    "Hp Mix",
    (input) => input.headphonesMix(),
    (value) => {
      engine.setValue("[Master]", "headMix", scaleToCrossfade(value));
    },
  );
  handleValueChange(
    "main",
    "Hp Vol",
    (input) => input.headphonesVolume(),
    (value) => {
      engine.setValue("[Master]", "headGain", scaleToGain(value));
    },
  );
  handleValueChange(
    "main",
    "Xfade",
    (input) => input.crossfader(),
    (value) => {
      engine.setValue("[Master]", "crossfader", scaleToCrossfade(value));
    },
  );

  // Handle changes for each side
  for (const { channel, side } of mappings) {
    const eqRack = `[EqualizerRack1_${channel}_Effect1]`;
    const fxRack = `[QuickEffectRack1_${channel}]`;

    // Set side knob and fader values
    handleValueChange(
      side,
      "Gain",
      (input) => input.gain(side),
      (value) => {
        engine.setValue(channel, "pregain", scaleToGain(value));
      },
    );
    handleValueChange(
      side,
      "Hi",
      (input) => input.hi(side),
      (value) => {
        engine.setValue(eqRack, "parameter3", scaleToGain(value));
      },
    );
    handleValueChange(
      side,
      "Mid",
      (input) => input.mid(side),
      (value) => {
        engine.setValue(eqRack, "parameter2", scaleToGain(value));
      },
    );
    handleValueChange(
      side,
      "Low",
      (input) => input.low(side),
      (value) => {
        engine.setValue(eqRack, "parameter1", scaleToGain(value));
      },
    );
    handleValueChange(
      side,
      "FX",
      (input) => input.fx(side),
      (value) => {
        engine.setValue(fxRack, "super1", value);
      },
    );
    handleValueChange(
      side,
      "Volume",
      (input) => input.fader(side),
      (value) => {
        engine.setValue(channel, "volume", value);
      },
    );

    // Handle toggle FX
    if (input.fxToggle(side) && !oldInput.fxToggle(side)) {
      toggleBoolean(fxRack, "enabled");
      if (isDebugging) {
        console.debug(`FX toggled for channel ${channel}`);
      }
    }

    // Handle toggle prelisten
    if (buttonWasPressed((input) => input.prelistenToggle(side))) {
      toggleBoolean(channel, "pfl");
      if (isDebugging) {
        console.debug(`Prelisten toggled for channel ${channel}`);
      }
    }

    // Handle FX switch buttons
    for (let n = 1; n <= 5; n++) {
      if (buttonWasPressed((input) => input.fxSwitch(n))) {
        const numChainPresets = engine.getValue(fxRack, "num_chain_presets");
        if (n < numChainPresets) {
          console.debug(
            `Loading quick effect chain preset ${n}/${numChainPresets} for channel ${channel}`,
          );
          engine.setValue(fxRack, "loaded_chain_preset", n);
          lightsChanged = true;

          // Workaround for FX super wheel not updating if preset is loaded at the same time
          engine.beginTimer(
            1,
            () => {
              engine.setValue(fxRack, "super1", input.fx(side));
            },
            true,
          );

          changeDescriptions.main = {
            label: "FX",
            value: `#${n}`,
          };
        } else {
          console.warn(
            `Attempt to load quick effect chain preset ${n}/${numChainPresets}, but no such preset exists`,
          );
        }
      }
    }
  }

  return { lightsChanged, changeDescriptions };
};

const updateLightsFromEngine = (
  lights: LightsStatus,
  colors: ColorConfig,
  force: boolean,
): void => {
  const oldValue = lights.toMessage();

  // Update eq switch
  const eqSwitchColor =
    colors.eqSwitch === "default" ? colors.theme : colors.eqSwitch;
  lights.eqModeSwitch.left = DIM_COLORS[eqSwitchColor];
  lights.eqModeSwitch.right = DIM_COLORS[eqSwitchColor];

  // Update stems switch
  const stemsSwitchColor =
    colors.stemsSwitch === "default" ? colors.theme : colors.stemsSwitch;
  lights.stemsModeSwitch.left = DIM_COLORS[stemsSwitchColor];
  lights.stemsModeSwitch.right = DIM_COLORS[stemsSwitchColor];

  // Work out which effect presets are currently active
  const activeEffectPresets = new Set();
  for (const { channel } of mappings) {
    const fxRack = `[QuickEffectRack1_${channel}]`;
    const activeEffectPreset = engine.getValue(fxRack, "loaded_chain_preset");
    activeEffectPresets.add(activeEffectPreset);
  }

  // Update FX switching buttons
  for (let n = 1; n <= 5; n++) {
    const filterSwitchColor = colors.fx[n - 1] ?? "blue";
    const colorWithStatus = activeEffectPresets.has(n)
      ? filterSwitchColor
      : DIM_COLORS[filterSwitchColor];
    if (n === 5) {
      lights.fxFilterSwitch = colorWithStatus;
    } else {
      lights.fxSwitches[n - 1] = colorWithStatus;
    }
  }

  // Update lights for each side
  for (const { channel, side } of mappings) {
    const fxRack = `[QuickEffectRack1_${channel}]`;

    // Update FX toggle light
    const activeEffectPreset = engine.getValue(fxRack, "loaded_chain_preset");
    if (activeEffectPreset < 1 || activeEffectPreset > 5) {
      lights.fxToggle[side] = "black";
    } else {
      const isActive = engine.getValue(fxRack, "enabled") !== 0;
      const fxColor = colors.fx[activeEffectPreset - 1] ?? "blue";
      lights.fxToggle[side] = isActive ? fxColor : DIM_COLORS[fxColor];
    }

    // Update prelisten toggle light
    const prelistenEnabled = engine.getValue(channel, "pfl") !== 0;
    const prelistenColor =
      colors.prelistenToggle !== "default"
        ? colors.prelistenToggle
        : colors.theme;
    lights.prelistenToggle[side] = prelistenEnabled
      ? prelistenColor
      : DIM_COLORS[prelistenColor];

    // Update VU meter
    lights.vuLevel[side] = engine.getValue(channel, "VuMeter") * 10;

    // Update bottom LEDs
    const isBeatActive = engine.getValue(channel, "beat_active") !== 0;
    for (let i = 0; i < 6; i++) {
      const individualColor = colors.bottomLeds[i] ?? "default";
      const color =
        individualColor !== "default"
          ? individualColor
          : colors.bottomLedsDefault !== "default"
            ? colors.bottomLedsDefault
            : colors.theme;
      lights.bottomLeds[side][i] = isBeatActive ? color : DIM_COLORS[color];
    }
  }

  const newValue = lights.toMessage();
  let isChanged = false;
  for (let i = 0; i < oldValue.length; i++) {
    if (newValue[i] !== oldValue[i]) {
      isChanged = true;
      break;
    }
  }

  if (isChanged || force) {
    lights.send();
  }
};

class TraktorZ1MK2Class {
  id: string = "";
  isDebugging = false;
  currentInput: InputMessage = InputMessage.load(NULL_INPUT);
  lights: LightsStatus = new LightsStatus();
  colorConfig: ColorConfig = DEFAULT_COLOR_CONFIG;
  lightsTimer?: engine.TimerID;
  leftScreen = new ScreenData(0);
  centerScreen = new ScreenData(1);
  rightScreen = new ScreenData(2);

  init(id: string, isDebugging: boolean): void {
    this.id = id;
    this.isDebugging = isDebugging;
    if (this.isDebugging) {
      console.log(`TraktorZ1Mk2 initialized with id: ${id}`);
    }

    updateLightsFromEngine(this.lights, this.colorConfig, true);

    this.lightsTimer = engine.beginTimer(25, () => {
      updateLightsFromEngine(this.lights, this.colorConfig, false);
    });

    this.centerScreen.writeTextBig("Mixxx", 0, 0, 0, 0);
    this.leftScreen.send();
    this.centerScreen.send();
    this.rightScreen.send();
  }

  shutdown(): void {
    // Stop the timer to update lights
    if (this.lightsTimer) {
      engine.stopTimer(this.lightsTimer);
      this.lightsTimer = undefined;
    }

    // Turn off all the lights
    this.lights.clear();
    this.lights.send();

    // Clear all the screens
    this.leftScreen.clear();
    this.leftScreen.send();
    this.centerScreen.clear();
    this.centerScreen.send();
    this.rightScreen.clear();
    this.rightScreen.send();
  }

  incomingData(data: Uint8Array, _length: number): void {
    let message: InputMessage;
    try {
      message = InputMessage.load(data);
    } catch (e) {
      console.warn(`Error loading input message: ${e}`);
      return;
    }
    const { lightsChanged, changeDescriptions } = updateEngineFromInput(
      message,
      this.currentInput,
      this.isDebugging,
    );
    if (lightsChanged) {
      updateLightsFromEngine(this.lights, this.colorConfig, false);
    }
    if (changeDescriptions.left) {
      this.leftScreen.clear();
      this.leftScreen.writeTextBig(changeDescriptions.left.label, 0, 0, 0, 1);
      this.leftScreen.writeTextBig(changeDescriptions.left.value, 0, 1, 0, 0);
      this.leftScreen.send();
    }
    if (changeDescriptions.main) {
      this.centerScreen.clear();
      this.centerScreen.writeTextBig(changeDescriptions.main.label, 0, 0, 0, 1);
      this.centerScreen.writeTextBig(changeDescriptions.main.value, 0, 1, 0, 0);
      this.centerScreen.send();
    }
    if (changeDescriptions.right) {
      this.rightScreen.clear();
      this.rightScreen.writeTextBig(changeDescriptions.right.label, 0, 0, 0, 1);
      this.rightScreen.writeTextBig(changeDescriptions.right.value, 0, 1, 0, 0);
      this.rightScreen.send();
    }
    this.currentInput = message;
  }
}

// eslint-disable-next-line no-var
var TraktorZ1MK2 = new TraktorZ1MK2Class();
